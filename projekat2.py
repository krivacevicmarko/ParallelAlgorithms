# -*- coding: utf-8 -*-
"""Projekat2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ZLtFhOf2BvCbZVmUTTYTM_q_gB7V9_N4

**Ucitavanje podataka**
"""

import os
import shutil
import pickle
import numpy as np
from urllib.request import urlretrieve
import tarfile
from collections import defaultdict
from PIL import Image

def prepare_cifar10_selected_classes(root='./data', processed_root='./data/cifar10_processed', train_samples_per_class=100, test_samples_per_class=10):
    selected_classes = ['frog', 'dog', 'cat', 'horse', 'bird']

    url = "https://www.cs.toronto.edu/~kriz/cifar-10-python.tar.gz"
    filename = "cifar-10-python.tar.gz"
    cifar_path = os.path.join(root, filename)
    extract_path = os.path.join(root, 'cifar-10-batches-py')

    if not os.path.exists(cifar_path):
        os.makedirs(root, exist_ok=True)
        print("Downloading CIFAR-10...")
        urlretrieve(url, cifar_path)

    if not os.path.exists(extract_path):
        print("Extracting CIFAR-10...")
        with tarfile.open(cifar_path, 'r:gz') as tar:
            tar.extractall(path=root)

    def load_batch(file_path):
        with open(file_path, 'rb') as f:
            batch = pickle.load(f, encoding='bytes')
        return batch

    class_names = [
        'airplane', 'automobile', 'bird', 'cat', 'deer',
        'dog', 'frog', 'horse', 'ship', 'truck'
    ]
    data_batches = [f'data_batch_{i}' for i in range(1, 6)]
    class_images = defaultdict(list)
    class_counts = {name: 0 for name in class_names}

    for batch_file in data_batches:
        batch_path = os.path.join(extract_path, batch_file)
        batch = load_batch(batch_path)
        images = batch[b'data']
        labels = batch[b'labels']

        for img, label in zip(images, labels):
            class_name = class_names[label]
            if class_name in selected_classes and class_counts[class_name] < train_samples_per_class + test_samples_per_class:
                img_reshaped = img.reshape(3, 32, 32).transpose(1, 2, 0)
                class_images[class_name].append(img_reshaped)
                class_counts[class_name] += 1
            if all(class_counts[c] >= train_samples_per_class + test_samples_per_class for c in selected_classes):
                break

    if os.path.exists(processed_root):
        shutil.rmtree(processed_root)
    os.makedirs(processed_root)

    train_data = []
    test_data = []

    for class_name in selected_classes:
        class_dir = os.path.join(processed_root, class_name)
        os.makedirs(class_dir, exist_ok=True)

        images = class_images[class_name]

        for i, img in enumerate(images[:train_samples_per_class]):
            img_path = os.path.join(class_dir, f"{class_name}_train_{i}.png")
            save_image(img, img_path)
            train_data.append((class_name, img_path))

        for i, img in enumerate(images[train_samples_per_class:train_samples_per_class + test_samples_per_class]):
            img_path = os.path.join(class_dir, f"{class_name}_test_{i}.png")
            save_image(img, img_path)
            test_data.append((class_name, img_path))

    return train_data, test_data

def save_image(img, path):
    image = Image.fromarray(img)
    image.save(path)

train_data, test_data = prepare_cifar10_selected_classes()

"""**Funkcija za racunanje histograma jedne slike**"""

from PIL import Image
from functools import reduce
import numpy as np

NUM_BINS = 16

def calculate_normalized_bins_histograms(image_path):
    image = Image.open(image_path)
    image = image.convert('RGB')
    width, height = image.size
    total_pixels = width * height

    bin_size = 256 // NUM_BINS

    pixels = list(image.getdata())

    def pixel_to_bins(pixel):
        r, g, b = pixel
        return (r // bin_size, g // bin_size, b // bin_size)

    binned_pixels = map(pixel_to_bins, pixels)

    def update_histograms(hist, bin_indices):
        r_bin, g_bin, b_bin = bin_indices
        hist[0][r_bin] += 1
        hist[1][g_bin] += 1
        hist[2][b_bin] += 1
        return hist

    initial_hist = [
        np.zeros(NUM_BINS, dtype=np.float32),
        np.zeros(NUM_BINS, dtype=np.float32),
        np.zeros(NUM_BINS, dtype=np.float32)
    ]

    histograms = reduce(update_histograms, binned_pixels, initial_hist)

    normalized_histograms = list(map(lambda hist: hist / total_pixels, histograms))

    return np.stack(normalized_histograms, axis=0)

"""**Funkcija za racunanje prosecnog histograma klasa**"""

from functools import reduce
import numpy as np

NUM_BINS = 16

def count_elements(collection):
    return reduce(lambda acc, _: acc + 1, collection, 0)

def calculate_average_histograms(image_data):
    sorted_data = sorted(image_data, key=lambda x: x[0])

    def group_by_class(acc, item):
        class_name, image_path = item
        if class_name not in acc:
            acc[class_name] = []
        acc[class_name].append(image_path)
        return acc

    grouped_data = reduce(group_by_class, sorted_data, {})

    def calculate_class_histogram(class_name, image_paths):
        histograms = map(calculate_normalized_bins_histograms, image_paths)

        def sum_histograms(acc, hist):
            return list(map(lambda x, y: x + y,acc,hist))

        initial_hist = [
            np.zeros(NUM_BINS, dtype=np.float32),
            np.zeros(NUM_BINS, dtype=np.float32),
            np.zeros(NUM_BINS, dtype=np.float32)
        ]

        total_histogram = reduce(sum_histograms, histograms, initial_hist)

        num_images = count_elements(image_paths)

        average_histogram = list(map(lambda hist: hist / num_images, total_histogram))

        return np.stack(average_histogram, axis=0)

    result = list(map(
        lambda item: (item[0], calculate_class_histogram(item[0], item[1])),
        grouped_data.items()
    ))

    return result

average_histograms_test = calculate_average_histograms(train_data)

first_class_name, first_avg_hist = average_histograms_test[0]

print("Prvi element average_histograms_test:")
print(f"Class: {first_class_name}")
print(f"Average Histogram Shape: {first_avg_hist.shape}")
print(f"Average Histogram Values: \n{first_avg_hist}")

print(average_histograms_test[1])

"""**Funkcija za izracunavanje kosinusne slicnosti**"""

from functools import reduce

def cosine_similarity(hist1, hist2):
    flat_hist1 = hist1.flatten()
    flat_hist2 = hist2.flatten()

    dot_product = reduce(lambda acc, x: acc + x[0] * x[1], zip(flat_hist1, flat_hist2), 0)

    norm1 = (reduce(lambda acc, x: acc + x**2, flat_hist1, 0)) ** 0.5
    norm2 = (reduce(lambda acc, x: acc + x**2, flat_hist2, 0)) ** 0.5

    if norm1 == 0 or norm2 == 0:
        return 0.0

    similarity = dot_product / (norm1 * norm2)
    return similarity

"""**Funkcija za klasifikaciju**"""

def classify_image(image_path, average_histograms):
    image_histogram = calculate_normalized_bins_histograms(image_path)

    similarities = map(
        lambda class_hist: (
            class_hist[0],
            cosine_similarity(image_histogram, class_hist[1])
        ),
        average_histograms
    )

    best_match = reduce(
        lambda acc, current: current if current[1] > acc[1] else acc,
        similarities,
        ("", -1)
    )


    predicted_class, similarity = best_match
    return image_path, predicted_class, similarity

"""**Proba klasifikacije sa jednom testnom slikom**"""

test_image_path = test_data[5][1]
average_histograms = calculate_average_histograms(train_data)
result = classify_image(test_image_path, average_histograms)

print(result)
print(f"Image Path: {result[0]}")
print(f"Predicted Class: {result[1]}")
print(f"Similarity: {result[2]}")

"""**Klasifikacija celog test skupa**"""

classification_results = list(map(
    lambda img: classify_image(img[1], average_histograms),
    test_data
))

correct_predictions = sum(
    1 for result, actual in zip(classification_results, test_data) if result[1] == actual[0]
)
total_predictions = len(test_data)
accuracy = (correct_predictions / total_predictions) * 100

print("Classification Results:")
for result in classification_results:
    print(f"Image Path: {result[0]}")
    print(f"Predicted Class: {result[1]}")
    print(f"Similarity: {result[2]}")
    print("-" * 30)

print(f"Accuracy: {accuracy:.2f}%")